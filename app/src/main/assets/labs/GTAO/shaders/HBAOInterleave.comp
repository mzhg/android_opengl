
#include "GTAOCommon.glsl"

#if SHADER_QUALITY == 0
// very low
#define GTAO_NUMTAPS 4
#define GTAO_BIASMIPLEVEL 2
#define GTAO_MAX_PIXEL_SCREEN_RADIUS 64.0f
#define HBAO_NUMANGLES 2
#elif SHADER_QUALITY == 1
// low
#define GTAO_NUMTAPS 6
#define GTAO_BIASMIPLEVEL 1
#define GTAO_MAX_PIXEL_SCREEN_RADIUS 64.0f
#define HBAO_NUMANGLES 4
#elif SHADER_QUALITY == 2
// medium
#define GTAO_NUMTAPS 8
#define GTAO_BIASMIPLEVEL 0
#define GTAO_MAX_PIXEL_SCREEN_RADIUS 64.0f
#define HBAO_NUMANGLES 6
#elif SHADER_QUALITY == 3
// high
#define GTAO_NUMTAPS 12
#define GTAO_BIASMIPLEVEL 0
#define GTAO_MAX_PIXEL_SCREEN_RADIUS 64.0f
#define HBAO_NUMANGLES 8
#else // SHADER_QUALITY == 4
// very high
#define GTAO_NUMTAPS 20
#define GTAO_BIASMIPLEVEL 0
#define GTAO_MAX_PIXEL_SCREEN_RADIUS 64.0f
#define HBAO_NUMANGLES 10
#endif

layout(binding = 0) uniform sampler2DArray DepthInterleaveTexture;
//Texture2D<float>      DepthLinearTexture : register(t1);
layout(binding = 1) uniform sampler2D     ViewNormalTexture;

/*SamplerState SamplerLinear : register(s0);
SamplerState SamplerPoint : register(s1);*/

float3 GetQuarterCoord(float2 UV, uint PrimitiveID)
{
    return float3(UV, float(PrimitiveID));
}

float GetLinearDepthProj(float2 ScreenUV, uint slice)
{
    return textureLod(DepthInterleaveTexture, GetQuarterCoord(ScreenUV, slice), 0.0).x;  // SamplerPoint
}

float3 GetViewSpacePosFromAOInput(float2 ScreenUV, uint slice)
{
    float ViewDepth = GetLinearDepthProj(ScreenUV, slice);
    float3 ViewPosition = ScreenToViewPos(ScreenUV, ViewDepth);
    return ViewPosition;
}

// ---------------------------------------------   No interleave version
float ComputeCoarseAO(float2 FullResUV, float RadiusPixels, float3 Rand, float3 ViewPosition, float3 ViewNormal, uint Slice)
{
    // Divide by NUM_STEPS+1 so that the farthest samples are not fully attenuated
    const int HBAO_NUMTAPS = GTAO_NUMTAPS / 2;
    float StepSizePixels = RadiusPixels / float(HBAO_NUMTAPS + 1);
    const int NUM_DIRECTIONS = HBAO_NUMANGLES;
    const float Alpha = 3.1415926 / float(NUM_DIRECTIONS);
    float AO = 0.0;
    float SinDeltaAngle = sin(Alpha);
    float CosDeltaAngle = cos(Alpha);
    float2 Direction = Rand.xy;
    for (int DirectionIndex = 0; DirectionIndex < NUM_DIRECTIONS; ++DirectionIndex)
    {
        // Jitter starting sample within the first step
        float RayPixels = (Rand.z * StepSizePixels + 1.0);
        for (int StepIndex = 0; StepIndex < HBAO_NUMTAPS; ++StepIndex)
        {
            float2 UVOffset = round(RayPixels * Direction) * BufferSizeAndInvSize.zw * 4.0;
            {
                float2 SnappedUV = FullResUV + UVOffset;
                float3 S = GetViewSpacePosFromAOInput(SnappedUV, Slice);
                AO += ComputeAO(ViewPosition, ViewNormal, S);
            }
            {
                float2 SnappedUV = FullResUV - UVOffset;
                float3 S = GetViewSpacePosFromAOInput(SnappedUV, Slice);
                AO += ComputeAO(ViewPosition, ViewNormal, S);
            }
            RayPixels += StepSizePixels;
        }
        // Rotate for the next angle
        float2 TempScreenDir = Direction.xy;
        Direction.x = (TempScreenDir.x *  CosDeltaAngle) + (TempScreenDir.y * -SinDeltaAngle);
        Direction.y = (TempScreenDir.x *  SinDeltaAngle) + (TempScreenDir.y * CosDeltaAngle);
    }
    // TODO: AOMultiplier should be a paramter
    float AOMultiplier = HBAO_Multiplier;
    AO *= AOMultiplier / float(NUM_DIRECTIONS * HBAO_NUMTAPS);
    return clamp(1.0 - AO * 2.0, 0.0, 1.0);
}

float HBAOCombinedPSandCS(in float2 UV, in uint3 iPos, float ViewDepth)
{
    float2 AOSceneViewport_Extent = BufferSizeAndInvSize.xy / 4.0;
    float2 AOSceneViewport_ExtentInverse = BufferSizeAndInvSize.zw * 4.0;
    // Offset by a fraction of a pixel to unsure we don't hit between pixels when running at half res
    float2 QuarterOffset = AOSceneViewport_ExtentInverse * 0.125;
    float2 TexUV = UV + QuarterOffset;
    UV += QuarterOffset;


    //	float DeviceZ = LookupDeviceZ(TexUV);
    //	float SceneDepth = ConvertFromDeviceZ(DeviceZ);
    float SceneDepth = GetLinearDepthProj(TexUV, iPos.z);
    if (SceneDepth > AmbientOcclusionFadeDistance)
    {
        return 1.0;
    }
    ViewDepth = SceneDepth;
    float3 ViewPosition = ScreenToViewPos(UV, SceneDepth);
    //        float3 ViewPosition = GetViewSpacePosFromAOInput(UV);
    // Reconstruct view-space normal from nearest neighbors
//    float3 ViewNormal = GetNormal(UV, ThreadPos, ViewPosition);
    float3 ViewNormal = texelFetch(ViewNormalTexture, int2(iPos.xy), 0).xyz * 2.0 - 1.0;  // SamplerLinear
    // Compute projection of disk of radius R into screen space
    float RadiusPixels = GetSearchingPixelRadiusHBAO(SceneDepth, true,GTAO_MAX_PIXEL_SCREEN_RADIUS,GTAO_NUMTAPS);
    // Get jitter vector for the current full-res pixel
//    float3 Rand = GetRandomVector(iPos.xy);
    float3 Rand = GetJitter(int(iPos.z));
    float AO = ComputeCoarseAO(UV, RadiusPixels, Rand, ViewPosition, ViewNormal, iPos.z);
    return AO;
    //        return float4(ViewNormal * 0.5 + 0.5,AO);
}

#ifndef THREADGROUP_SIZEX
#define THREADGROUP_SIZEX 8
#define THREADGROUP_SIZEY 4
#endif

writeonly layout(OUT_FORMAT, binding = 0) uniform image2DArray OutTexture;
layout(local_size_x = THREADGROUP_SIZEX, local_size_y = THREADGROUP_SIZEY, local_size_z = 1) in;
void /*GTAOCombinedCS*/main()
{
    uint GroupIndex = gl_LocalInvocationIndex;
    uvec3 GroupId = gl_WorkGroupID;
    uvec3 DispatchThreadId = gl_GlobalInvocationID;
    uvec3 GroupThreadId = gl_LocalInvocationID;

    float OutColor = 0.0;
    float ViewDepth = 0.0;

    const uint AOViewport_ViewportMin = 0u;
    int3   PixelPos = int3(DispatchThreadId.xy + AOViewport_ViewportMin, DispatchThreadId.z);
    float2 Offset = float2(float(PixelPos.z % 4), float(PixelPos.z / 4));
    float2 Base = float2(PixelPos.xy) * 4.0 + Offset + 0.5;
    //	float2 uv = base * (InvQuarterResolution / 4.0);
    float2 BufferUV = Base * GTAOParams[2].zw;

    OutColor = HBAOCombinedPSandCS(BufferUV, uint3(Base, PixelPos.z), ViewDepth);

//    OutTexture[PixelPos] = float2(pow(OutColor, 1), ViewDepth);
//    imageStore(OutTexture, PixelPos, uint4(EncodeAOZ(pow(OutColor, 1.0), ViewDepth),0,0,0));
    imageStore(OutTexture, PixelPos, float4(OutColor, 0,0,0));
}