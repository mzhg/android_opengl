#include "ShardMemoryCommon.glsl"

// ---------------------------------------------   No interleave version
float ComputeCoarseAO(float2 FullResUV, float RadiusPixels, float3 Rand, float3 ViewPosition, float3 ViewNormal)
{
    // Divide by NUM_STEPS+1 so that the farthest samples are not fully attenuated
    const int HBAO_NUMTAPS = GTAO_NUMTAPS / 2;
    float StepSizePixels = RadiusPixels / float(HBAO_NUMTAPS + 1);
    const int NUM_DIRECTIONS = HBAO_NUMANGLES;
    const float Alpha = 3.1415926 / float(NUM_DIRECTIONS);
    float AO = 0.0;
    float SinDeltaAngle = sin(Alpha); //WorldRadiusAdj_SinDeltaAngle_CosDeltaAngle_Thickness.y;
    float CosDeltaAngle = cos(Alpha); //WorldRadiusAdj_SinDeltaAngle_CosDeltaAngle_Thickness.z;
    float2 Direction = Rand.xy;
    for (int DirectionIndex = 0; DirectionIndex < NUM_DIRECTIONS; ++DirectionIndex)
    {
        // Jitter starting sample within the first step
        float RayPixels = (Rand.z * StepSizePixels + 1.0);
        for (int StepIndex = 0; StepIndex < HBAO_NUMTAPS; ++StepIndex)
        {
            float2 UVOffset = round(RayPixels * Direction) * BufferSizeAndInvSize.zw;
            {
                float2 SnappedUV = FullResUV + UVOffset;
                float3 S = GetViewSpacePosFromAOInput(SnappedUV);
                AO += ComputeAO(ViewPosition, ViewNormal, S);
            }
            {
                float2 SnappedUV = FullResUV - UVOffset;
                float3 S = GetViewSpacePosFromAOInput(SnappedUV);
                AO += ComputeAO(ViewPosition, ViewNormal, S);
            }
            RayPixels += StepSizePixels;
        }
        // Rotate for the next angle
        float2 TempScreenDir = Direction.xy;
        Direction.x = (TempScreenDir.x *  CosDeltaAngle) + (TempScreenDir.y * -SinDeltaAngle);
        Direction.y = (TempScreenDir.x *  SinDeltaAngle) + (TempScreenDir.y * CosDeltaAngle);
    }

    float AOMultiplier = HBAO_Multiplier;
    AO *= AOMultiplier / float(NUM_DIRECTIONS * HBAO_NUMTAPS);

    return clamp(1.0 - AO * 2.0, 0.0, 1.0);
}

float HBAOCombinedPSandCS(in float2 UV, in int2 iPos, int2 ThreadPos)
{
    float SceneDepth = GetSceneDepthFromSharedMemory(ThreadPos + DEPTH_GROUP_THREAD_OFFSET);
    if (SceneDepth > FadeRadiusMulAdd_FadeDistance_AttenFactor.z)
    {
        return 1.0;
    }
    float3 ViewPosition = ScreenToViewPos(UV, SceneDepth);
    //        float3 ViewPosition = GetViewSpacePosFromAOInput(UV);
    // Reconstruct view-space normal from nearest neighbors
    float3 ViewNormal = GetNormal(UV, ThreadPos, ViewPosition);
    float RadiusPixels = GetSearchingPixelRadiusHBAO(SceneDepth, false,GTAO_MAX_PIXEL_SCREEN_RADIUS,GTAO_NUMTAPS);

    // Get jitter vector for the current full-res pixel
//    float3 Rand = GetRandomVector(uint2(iPos));
    float3 Rand = GetJitter(iPos);
    float AO = ComputeCoarseAO(UV, RadiusPixels, Rand, ViewPosition, ViewNormal);
    return AO;
//        return float4(ViewNormal * 0.5 + 0.5,AO);
}

void CacheZVal(int2 FullGroupOriginDepth, int pixIdx)
{
    int2 ThreadPos;

    ThreadPos.x = pixIdx % DEPTH_THREADPOS_OFFSET;
    ThreadPos.y = pixIdx / DEPTH_THREADPOS_OFFSET;

    int2 TexturePos = FullGroupOriginDepth + ThreadPos;

    float2 TextureUV = TexturePosToBufferUV(TexturePos);

    TextureUV += BufferSizeAndInvSize.zw*0.125;

    SetZVal(GetDeviceZFromAOInput(TextureUV.xy), pixIdx);
}

//[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
layout(local_size_x = THREADGROUP_SIZEX, local_size_y = THREADGROUP_SIZEY, local_size_z = 1) in;
void /*GTAOHorizonSearchIntegralCS*/main(
/*int   GroupIndex : SV_GroupIndex,
uint2 GroupId : SV_GroupID,
uint2 DispatchThreadId : SV_DispatchThreadID,
uint2 GroupThreadId : SV_GroupThreadID
#if INSTANCED_STEREO
, uint InstanceId : SV_InstanceID
, out uint LayerIndex : SV_RenderTargetArrayIndex
#elif MOBILE_MULTI_VIEW
, in uint ViewId : SV_ViewID
, out float MultiViewIndex : VIEW_ID
#endif*/
)
{
    int   GroupIndex = int(SV_GroupIndex);
    uint2 GroupId = SV_GroupID.xy;
    uint2 GroupThreadId = SV_GroupThreadID.xy;
    uint2 DispatchThreadId = SV_DispatchThreadID.xy;
//    int2 FullGroupOrigin = int2(GroupId.x * THREADGROUP_SIZEX, GroupId.y * THREADGROUP_SIZEY);
    int2 FullGroupOrigin = int2(GroupId.xy) * int2(THREADGROUP_SIZEX, THREADGROUP_SIZEY);
    int pixIdx = GroupIndex;

    // Cache SceneDepth in Group Shared memory for calculating the normal from depth.
    {
        int2 FullGroupOriginDepth = FullGroupOrigin.xy - DEPTH_GROUP_THREAD_OFFSET;

        pixIdx = GroupIndex * 2;
        if (pixIdx < MAX_DEPTH_THREADS)
        {
            CacheZVal(FullGroupOriginDepth, pixIdx);

            CacheZVal(FullGroupOriginDepth, pixIdx + 1);
        }

        GroupMemoryBarrierWithGroupSync();
    }

    int2 ThreadPos = int2(GroupThreadId);
    int2 TexturePos = int2(DispatchThreadId);

    float2 TextureUV = TexturePosToBufferUV(TexturePos);

    float GTAO = HBAOCombinedPSandCS(TextureUV.xy, TexturePos.xy, ThreadPos.xy);
    float DeviceZ = GetDeviceZFromSharedMemory(ThreadPos + DEPTH_GROUP_THREAD_OFFSET);

    float4 EncodeZ = EncodeFloatRGBA(DeviceZ);
    EncodeZ.a = GTAO;
//    OutTexture[TexturePos] = EncodeZ;
    imageStore(OutTexture, TexturePos,EncodeZ );
}