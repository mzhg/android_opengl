#include "ShardMemoryCommon.glsl"

/// ----------------------- HBAO Code ----------------------------
float Falloff(float DistanceSquare)
{
    // fade radius inverse.
    // 1 scalar mad instruction
    float RadiusSq = WorldRadiusAdj_SinDeltaAngle_CosDeltaAngle_Thickness.w;
    return DistanceSquare / (-RadiusSq) + 1.0;
}
//----------------------------------------------------------------------------------
// P = view-space position at the kernel center
// N = view-space normal at the kernel center
// S = view-space position of the current sample
//----------------------------------------------------------------------------------
float ComputeAO(float3 P, float3 N, float3 S)
{
    float3 V = S - P;
    float VdotV = dot(V, V);
    float NdotV = dot(N, V) * rsqrt(VdotV);
    // Todo : NDotVBias should be parameter
    float NDotVBias = FadeRadiusMulAdd_FadeDistance_AttenFactor.w;
    return clamp(NdotV - NDotVBias, 0.0, 1.0) * clamp(Falloff(VdotV), 0.0, 1.0);
    //        return clamp((NdotV - NDotVBias) * Falloff(VdotV), 0, 1);
}
//----------------------------------------------------------------------------------
float2 RotateDirection(float2 Dir, float2 CosSin)
{
    return float2(Dir.x*CosSin.x - Dir.y*CosSin.y, Dir.x*CosSin.y + Dir.y*CosSin.x);
}
float2 _round(float2 v)
{
    int2 t = int2(v + 0.5);
    return float2(t);
}
// ---------------------------------------------   No interleave version
float ComputeCoarseAO(float2 FullResUV, float RadiusPixels, float3 Rand, float3 ViewPosition, float3 ViewNormal)
{
    // Divide by NUM_STEPS+1 so that the farthest samples are not fully attenuated
    const int HBAO_NUMTAPS = GTAO_NUMTAPS;
    float StepSizePixels = RadiusPixels / float(HBAO_NUMTAPS + 1);
    const int NUM_DIRECTIONS = 2;
    const float Alpha = 2.0 * 3.1415926 / float(NUM_DIRECTIONS);
    float AO = 0.0;
    float SinDeltaAngle = 0.0; //WorldRadiusAdj_SinDeltaAngle_CosDeltaAngle_Thickness.y;
    float CosDeltaAngle = -1.0; //WorldRadiusAdj_SinDeltaAngle_CosDeltaAngle_Thickness.z;
    float2 Direction = Rand.xy;
    for (int DirectionIndex = 0; DirectionIndex < NUM_DIRECTIONS; ++DirectionIndex)
    {
        // Jitter starting sample within the first step
        float RayPixels = (Rand.z * StepSizePixels + 1.0);
        for (int StepIndex = 0; StepIndex < HBAO_NUMTAPS; ++StepIndex)
        {
            float2 UVOffset = round(RayPixels * Direction) * BufferSizeAndInvSize.zw;
            {
                float2 SnappedUV = FullResUV + UVOffset;
                float3 S = GetViewSpacePosFromAOInput(SnappedUV);
                AO += ComputeAO(ViewPosition, ViewNormal, S);
            }
            {
                float2 SnappedUV = FullResUV - UVOffset;
                float3 S = GetViewSpacePosFromAOInput(SnappedUV);
                AO += ComputeAO(ViewPosition, ViewNormal, S);
            }
            RayPixels += StepSizePixels;
        }
        // Rotate for the next angle
        float2 TempScreenDir = Direction.xy;
        Direction.x = (TempScreenDir.x *  CosDeltaAngle) + (TempScreenDir.y * -SinDeltaAngle);
        Direction.y = (TempScreenDir.x *  SinDeltaAngle) + (TempScreenDir.y * CosDeltaAngle);
    }
    // TODO: AOMultiplier should be a paramter
    float AOMultiplier = FadeRadiusMulAdd_FadeDistance_AttenFactor.x;
    AO *= AOMultiplier / float(NUM_DIRECTIONS * HBAO_NUMTAPS);
    return clamp(1.0 - AO * 2.0, 0.0, 1.0);
}

float HBAOCombinedPSandCS(in float2 UV, in int2 iPos, int2 ThreadPos)
{
    float SceneDepth = GetSceneDepthFromSharedMemory(ThreadPos + DEPTH_GROUP_THREAD_OFFSET);
    if (SceneDepth > FadeRadiusMulAdd_FadeDistance_AttenFactor.z)
    {
        return 1.0;
    }
    float3 ViewPosition = ScreenToViewPos(UV, SceneDepth);
    //        float3 ViewPosition = GetViewSpacePosFromAOInput(UV);
    // Reconstruct view-space normal from nearest neighbors
    float3 ViewNormal = GetNormal(UV, ThreadPos, ViewPosition);
    // Compute projection of disk of radius R into screen space
    const float WorldRadius = 1.0;
    //        float InvTanHalfFov = ScreenSpaceAOParams[3].w;
//    float FOVScale = BufferSizeAndInvSize.y * View.ClipToView[1][1];
#if 0
    // Get Radius in ScreenSpace (in pixels)
    float WorldRadiusAdj = WorldRadius * FOVScale;
#else
    float WorldRadiusAdj = WorldRadiusAdj_SinDeltaAngle_CosDeltaAngle_Thickness.x /* SearchRadius*/;
#endif
    float RadiusPixels = max(min(WorldRadiusAdj / ViewPosition.z, GTAO_MAX_PIXEL_SCREEN_RADIUS), float(GTAO_NUMTAPS));
    // Get jitter vector for the current full-res pixel
    float3 Rand = GetRandomVector(uint2(iPos));
    float AO = ComputeCoarseAO(UV, RadiusPixels, Rand, ViewPosition, ViewNormal);
    return AO;
//        return float4(ViewNormal * 0.5 + 0.5,AO);
}

void CacheZVal(int2 FullGroupOriginDepth, int pixIdx)
{
    int2 ThreadPos;

    ThreadPos.x = pixIdx % DEPTH_THREADPOS_OFFSET;
    ThreadPos.y = pixIdx / DEPTH_THREADPOS_OFFSET;

    int2 TexturePos = FullGroupOriginDepth + ThreadPos;

    float2 TextureUV = TexturePosToBufferUV(TexturePos);

    TextureUV += BufferSizeAndInvSize.zw*0.125;

    SetZVal(GetDeviceZFromAOInput(TextureUV.xy), pixIdx);
}

//[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
layout(local_size_x = THREADGROUP_SIZEX, local_size_y = THREADGROUP_SIZEY, local_size_z = 1) in;
void /*GTAOHorizonSearchIntegralCS*/main(
/*int   GroupIndex : SV_GroupIndex,
uint2 GroupId : SV_GroupID,
uint2 DispatchThreadId : SV_DispatchThreadID,
uint2 GroupThreadId : SV_GroupThreadID
#if INSTANCED_STEREO
, uint InstanceId : SV_InstanceID
, out uint LayerIndex : SV_RenderTargetArrayIndex
#elif MOBILE_MULTI_VIEW
, in uint ViewId : SV_ViewID
, out float MultiViewIndex : VIEW_ID
#endif*/
)
{
    int   GroupIndex = int(SV_GroupIndex);
    uint2 GroupId = SV_GroupID.xy;
    uint2 GroupThreadId = SV_GroupThreadID.xy;
    uint2 DispatchThreadId = SV_DispatchThreadID.xy;
//    int2 FullGroupOrigin = int2(GroupId.x * THREADGROUP_SIZEX, GroupId.y * THREADGROUP_SIZEY);
    int2 FullGroupOrigin = int2(GroupId.xy) * int2(THREADGROUP_SIZEX, THREADGROUP_SIZEY);
    int pixIdx = GroupIndex;

    // Cache SceneDepth in Group Shared memory for calculating the normal from depth.
    {
        int2 FullGroupOriginDepth = FullGroupOrigin.xy - DEPTH_GROUP_THREAD_OFFSET;

        pixIdx = GroupIndex * 2;
        if (pixIdx < MAX_DEPTH_THREADS)
        {
            CacheZVal(FullGroupOriginDepth, pixIdx);

            CacheZVal(FullGroupOriginDepth, pixIdx + 1);
        }

        GroupMemoryBarrierWithGroupSync();
    }

    int2 ThreadPos = int2(GroupThreadId);
    int2 TexturePos = int2(DispatchThreadId);

    float2 TextureUV = TexturePosToBufferUV(TexturePos);

    float GTAO = HBAOCombinedPSandCS(TextureUV.xy, TexturePos.xy, ThreadPos.xy);
    float DeviceZ = GetDeviceZFromSharedMemory(ThreadPos + DEPTH_GROUP_THREAD_OFFSET);

    float4 EncodeZ = EncodeFloatRGBA(DeviceZ);
    EncodeZ.a = GTAO;
//    OutTexture[TexturePos] = EncodeZ;
    imageStore(OutTexture, TexturePos,EncodeZ );
}